### UML图和数据流图、
  + 逐句检查数据流图是否完整
  + 加工和实体名称一定用题干中的名称
  + UML图的使用场景
    + 结构图
      + 类图
      + 对象图
      + 包图
      + 组合结构图
      + 构件图
      + 部署图
      + 制品图
    + 行为图
      + 用例图
        + 泛化:**`名称中有相同内容的`，`基用例和子用例之间有共同内容的`**
        + 包含:**`多个基用例复用`,`跨越多个用例的相似动作`，`基用例可以依赖包含用例执行的结果`**
        + 扩展:**`扩展用例对基用例不可见`,`扩展用例可以访问基用例的属性`**
      + 交互图
        + 顺序图
          + 方法名称箭头指向的对象，是该对象应该实现的方法
        + 通讯图
      + 状态图
      + 活动图
### ER模型
  + 画联系的时候一定要画菱形填上联系名称(题干中给出)
  + 题干中为未提及的联系数量需要结合实际判断
  + 特殊化d，o 以及全部特殊或者部分特殊 也是一种联系，一定要检查！！！
  + 联系类型就是1:n,1:m,n:m,0
### 类图填空
  + 要画出题干中的关键字(用例、类、过程)
  + 填空尽量用题干中的关键字
### 算法填空
  + 注意事项
    + 结构体中的数据访问用->
    + 时间复杂度主要看 循环嵌套程度，for 和while,嵌套了几层就是几次方(循环次数都是用的一个变量值)
    + 时间复杂度中需要注意看嵌套循环是否是给定的m,n(循环次数都是用的不相同的变量值)
    + 给了递归式的第一空一般是第一种特殊情况
    + 给了递归式的一般是动态规划
    + 递归式中一般会有两个地方需要填写到

  |算法名称|算法原理|场景|
  |:--|:--:|--:|
  |分治法|将相同或相似的子问题一直分解到可以直接求解的程度<br>子问题的解合并即为原问题的解|归并排序、最大字段和|
  |贪心法|不追求最优解，以当前情况为基础做最优选择，而不是全局最优，不需要回溯|活动选择、部分背包|
  |动态规划法|求解包含重叠子问题(分解为相似的子问题)的最优化问题的方法<br>局部最优子结构|0-1背包、最长公共子序列|
  |回溯法|按选优条件向前搜索，达不到标准就回退再走|n皇后、0-1背包|
  |递归法|直接或间接调用自身，同时要有递归结束条件，递归前进段和递归返回段|-|
  
### [设计模式的代码实现](https://www.jianshu.com/p/2d16df9b1036)
  + 注意事项:
    + 类方法直接调用不用new
    + 抽象要抽出类中相同的 类和 变量
    + 注意子类要调用父类的方法，或者变量一定要把父类写成  protected 或者 public
    + 本类中调用属性可以加this也可以不加
    + 注意new的时候后面接类名，要注意构造函数是否有参数
    + 有些参数信息在注释中有提示，一定要写入实际需要的参数，不要当做在写类中的方法，不要写成形参！！！
    + 注意有些地方是否需要返回对象，需要的话一定记得写return！！！
  + **创建型模式**
    + 单例模式：`保证一个类仅有一个实例，并提供一个访问它的全局访问点`
    + 工厂方法模式FactoryMethod：`定义一个用于创建对象的接口，让子类决定实例化哪一个类`
    + **※抽象工厂模式AbstractFactory※**：`提供一个创建一系列相关或者相互依赖对象的接口，无需指定他们的具体类`
    + **※建造者模式(生成器)Bulider※**：`讲一个复杂对象的构建与它的表示相分离，同样的构建过程可以创建不同的表示`
    + **※原型模式Prototype※**：`用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象`
  + 结构型模式
    + **※适配器模式Adapter※**：`将一个类的接口转换成客户希望的另外一个接口`
    + **※桥接模式※**：`将抽象的部分与其实现的部分相分离，使他们可以独立变化，将N*M转化成N+M组合的思想`
    + **※装饰器模式Decorator※**：`允许向一个现有的对象添加新的功能，同时又不改变其结构`
    + [**※组合模式Compostie※**](https://www.bilibili.com/video/av63681488/?p=78)：`一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性`
    + 外观模式Facade：`隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口`
    + 享元模式FlyWeight：`用于减少创建对象的数量，以减少内存占用和提高性能`
    + **※代理模式Proxy※**：`为其他对象提供一种代理以控制对这个对象的访问`
  + 行为型模式
    + 模板方法模式Template：`一个抽象类公开定义了执行它的方法的方式/模板`
    + **※命令模式Command※**：`将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象`
    + 迭代器模式iterator：`用于顺序访问集合对象的元素，不需要知道集合对象的底层表示`
    + **※观察者模式Observer※**：`定义对象间的一种一对多的依赖关系`
    + 中介者模式Mediator：`用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散`
    + 备忘录模式Memento：`保存一个对象的某个状态，以便在适当的时候恢复对象`
    + 解释器模式：``
    + **※状态模式State※**：`类的行为是基于它的状态改变的`
    + **※策略模式※**：`定义一系列算法，把他们一个一个的封装起来，并且使他们可以相互替换`
    + 职责链模式Chain of Responsibility：``
    + **※访问者模式Visitor※**：`使用了一个访问者类，它改变了元素类的执行算法`
