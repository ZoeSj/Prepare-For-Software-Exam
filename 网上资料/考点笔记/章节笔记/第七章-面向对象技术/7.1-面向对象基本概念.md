### 面向对象技术
  + 面向对象的基本概念★★★
    + **对象**
      > 基本运行时的**实体**<br>
        数据库ER图中的实体<br>
        属性(数据)+方法(操作)+对象ID(唯一标识一个对象)
      + 对象的特性
        + 清晰的边界
        + 良好定义的行为
        + 可扩展性
    + **类**
      > 定义一组大体相似的**对象**<br>
        **类**中包含的是相似**对象**的共同**属性(数据)**、**方法(操作)**<br>
        **对象**是类的具体化<br>
        **对象**是类的实例<br>
        **类**的分类:实体类，接口类(边界类)，控制类<br>
        **类及对象**指类和这个类的所有对象
      + **类**的分类
        + 实体类
          > 存储和管理系统内部的信息，可以有行为，甚至很复杂的行为，行为必须与它代表的实体对象密切相关，实体类独立于系统外部环境<br>
            通常来自域模型（现实世界），用来描述具体的实体，通常映射到数据库表格与文件中
        + 接口类(边界类)
          > 描述系统外部环境和系统内部运作之间的交互，它工作在参与者和系统之间<br>
            通常是用来完成参与者（用户、外部系统）与系统之间交互的对象，例如：From、对话框、菜单、接口等
        + 控制类
          > 特定用例的控制行为<br>
            可以降低边界类和实体类之间的耦合<br>
            主要用来体现应用程序的执行逻辑，将其抽象出来，可以使变化不影响用户界面和数据库中的表
    + **继承**
      > **父类**和**子类**共享复用*属性(数据)*和*方法(操作)*的机制<br>
        **父类**可以有多个**子类**<br>
        **子类**是**父类**的特例
        A是父类，b，c，d是子类，可以说b，c，d**继承**自A
      + 单重继承
        > 从一个父类继承
      + 多重继承
        > 一个子类有多个父类
    + **泛化**
      > A是父类，b，c，d是子类，可以说b，c，d泛化自A<br>
        泛化一词在**UML**中使用频繁
    + **派生**
      > A是父类，b，c，d是子类，可以说A可以派生出b，c，d
    + **封装**
      > 隐藏**对象**的**属性(数据)**和**方法(操作)细节**，注意是隐藏对象和方法细节，不是隐藏类中的方法和属性！<br>
        对外只提供相应接口(方法)
    + **多态**
      > **同一类**的**对象**收到**同一消息**产生完全不同的结果<br>
        用户发送一个通用的消息，实现的细节由接收的**对象**自行决定
    + **绑定**
      + 静态绑定(前期绑定)
        > 编译器在编译时就把方法和所在类绑定
      + 动态绑定(后期绑定)
        > 程序运行时把方法和所在类绑定
      > 绑定指的是一个方法的调用与方法所在的类(方法主体)关联起来<br>
        父类中的**final**,**private**方法不能被子类继承，父类中的**static**静态方法可以被继承，但是不能重写，这三者都属于**前期绑定**<br>
        java中除了这三种以及构造方法之外剩下的都是后期绑定(运行是绑定)<br>
        java不推荐用对象调用static方法,这会使人混淆<br>
      >> 如果父类中有一个静态的方法，子类也有一个与其方法名，参数类型，参数个数都一样的方法，并且也有static关键字修饰，<br>那么该子类的方法会把原来继承过来的父类的方法**隐藏**，而**不是重写**。<br>通俗的讲就是父类的方法和子类的方法是两个没有关系的方法，具体调用哪一个方法是看是哪个对象的引用；这种父子类方法也不在存在多态的性质。<br>
      ---
        为什么abstract(抽象方法)修饰的method是不可同时是static的原因：
        >>> abstract修饰方法，子类需要重写去实现这个抽象方法，但是前期绑定又规定父类中`static`方法不能被子类重写，矛盾了<br>
            static修饰方法，则方法不属于某个对象，属于class，当父类的引用指向子类时，调用静态方法看引用，调用普通方法看对象,可用class名.方法名（），进行调用；
    + **消息**
      > msg.getMessage("hello")；对msg这个对象发送一个getMessage("hello")的消息，其中“.”就是告诉编译器后面是一条消息
    + **消息和消息通信**
      + 同步:`等待对象响应消息后再执行后续操作`
      + 异步:`不等待对象响应消息，消息发送后就执行后续操作`
    + **重写**
      > 关键字@Override
      + 发生在父类与子类之间 
      + 方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同（形参的名字可不一样）
      + 访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private) 
      + 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常
    + **重载**
      + 重载Overload是一个类中**多态性**的一种表现 
      + 重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序) 
      + 重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准
    + **特殊类**
      + [模板类](https://blog.csdn.net/qq78442761/article/details/79030616)(类属类)
        > 模板类用与表示通用的数据结构和算法
      + [接口](https://www.runoob.com/java/java-interfaces.html)
        > 特殊的**抽象类**，只有方法定义，没有方法实现细节<br>
          **接口**也是**抽象类**，抽象类实现接口可以重写接口里部分的方法或者不重写接口中的方法
        >> 当你自己写的类想用接口中个别方法的时候（注意不是所有的方法），那么你就可以用一个**抽象类**先实现这个接口（部分方法），然后再用你的类继承这个**抽象类**，这样就可以达到你的目的了，如果你直接用类实现**接口**，那是所有方法都必须实现的。
        + **接口**不能被实例化
        + **接口**只能包含方法声明(抽象方法)
        + **接口**的成员包括方法声明、属性、索引器、事件
        + **接口**中不能包含常量、字段(域)、构造函数、析构函数、静态成员(属性、方法)
      + [抽象类](https://www.runoob.com/java/java-abstraction.html)
        > 抽象类不能创建实例，它只能作为父类被继承<br>
          抽象类是从多个具体类中抽象出来的父类，它具有更高层次的抽象<br>
          以这个抽象类作为其子类的模板，从而避免了子类的随意性
        + **抽象类**可以没有**抽象方法**也可以有，可以有正常的方法(有实现细节)，也可以没有
        + **抽象方法**只作**声明**，而**不包含实现**，可以看成是没有实现体的**虚方法**
        + **抽象类**不能被**实例化**
        + **抽象类**可以但不是必须有**抽象属性**和**抽象方法**，但是一旦有了**抽象方法**，就一定要把这个类声明为**抽象类**
        + **具体派生类**必须**覆盖、实现**基类的**抽象方法**
        + **抽象派生类**(继承某抽象类的子类)可以覆盖基类的**抽象方法**，也可以不覆盖。如果不覆盖，则其**具体派生类**的子类必须**覆盖、实现**它们
      + 接口和抽象类的异同
        + 区别:
          + **抽象类**可以有**构造方法(有具体实现细节)**，接口中不能有**构造方法**。
          + **抽象类**中可以有**普通成员变量**，**接口**中没有**普通成员变量**
          + **抽象类**中可以包含**静态方法**，**接口**中不能包含**静态方法**
          + 一个类可以**实现多个接口**，但只能继承一个**抽象类**。
            ```java
            ...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...
            ```
          + 继承**抽象类**用 extends 关键字；实现**接口**用 implements 关键字。继承写在前面，实现接口写在后面
            ```java
            class className extends abstractClassName implements interfaceName1,interfaceName2,...{
                ...
            }
            ```
          + 接口可以被多重实现，抽象类只能被单一继承
          + 如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法
        + 相同:
          + 都可以被继承
          + 都不能被实例化
          + 都可以包含方法声明(抽象方法)
          + 派生类必须实现未实现的方法(抽象方法)
