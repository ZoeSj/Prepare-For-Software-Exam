### 机器数
  + 小数点不占位
  + 实际数值称为真值
  + 无符号机器数
    + 表示正数
    + 没有符号位
  + 带符号机器数
    + 正数
      + 纯整数:`小数点在最低位之后`
      + 纯小数:`小数点在最高位之前`
    + 负数
      + 纯整数:`小数点在最低位之后`
      + 纯小数:`小数点在最高位之前`
  + #### 码制(page5)
    + `原码`:正数反码补码和它相同，要分+0和-0
    + `反码`:正数原码补码和它相同，要分+0和-0
    + [`补码`](https://blog.csdn.net/searchin_r/article/details/84075902):正数反码原码和它相同
      + 补码不分+0和-0，例如:1000 0000 表示的是-128而不是-0
      + > 负数的补码=模-|数值| `模=1(二进制数值位数个0)`</br>模和数值都是二进制，而且并没有编码成`原反补移`</br> 例如 -127 => 1111111（7位）</br>模 = 1000 0000(第一位不是符号位)</br>-127的补码 = 1000 0000 - 1111111 = 1000 0001</br>-128的补码 = 10000 0000 - 1000 0000 = 1000 0000(0在补码中只能表示为0000 0000，所以不要理解为-0)
    + `移码`:增加一个2<sup>n-1</sup>的偏移量来表示
      > IEEE754规格化中偏移量并不是2<sup>8-1</sup>=128,而是规定的+127作为偏移量</br>规格化中要求的阶码用移码表示的意思是，先将E转换成二进制带符号(直接带正负号，**不是`码制`中的第一位来表示正负**)</br>例如:规格化后的1.25 × 2<sup>-2</sup>;E = -10<sub>(2)</sub>,阶码的长度不同的规格化要求不同，IEEE754要求的是8位，则阶码为-0000 0010 + 0111 1111 = 0111 1101
  + #### 定点数
    + 小数点位置固定不变
    + 定点数各种码制范围(page7-1-1)
  + #### 浮点数
    + 扩展数值范围
    + N=R<sup>E</sup> × F 
      > R代表基数`因为这里说的是二进制，所以基数为2` </br>E代表阶数</br>F代表尾数
      + E:阶码`带符号的纯整数`
      + F:尾数`带符号的纯小数`
    + 原码和反码在位长n的时候能表示2<sup>n</sup>-1个数，因为[-0]和[+0]都是代表的0，例如:1000 0000和0000 0000都是表示0但是表示方式却不一样，所以需要-1
    + > 补码和移码在位长n的时候能表示2<sup>n</sup>个数</br>
    补码1000 0000代表的是-128而不是[-0],补码=模-|数值|</br>
    +0的原码是0000 0000 -0的原码是1000 0000</br>
    +0的反码是0000 0000 -0的反码是1111 1111</br>
    +0和-0的补码均为0000 0000</br>
    +0和-0的移码均为1000 0000
    + ##### 浮点数规格化
      + N = M × R<sup>E</sup>
        > N是数值</br>M是尾数</br>R是基数`2、8、16进制`</br>E是阶码`用移码表示`
        + 一般规格化有不同的参数要求
          + IEEE754 要求偏移量为 2<sup>8-1</sup> -1 = 127，所以IEEE754规格化中求阶码需要+127,而不是2<sup>8-1</sup>=128(8是IEEE754中阶码长度)
          + IEEE754 要求M尾数b<sub>0</sub>b<sub>1</sub>b<sub>2</sub>b<sub>3</sub>...b<sub>4</sub>b<sub>p-1</sub>实际有效数位的最高位为1，且小数点在最高有效数位的右边，因为只要按照IEEE754规格化后尾数的实际有效数位b<sub>0</sub>一直等于1，所以去掉b<sub>0</sub>,剩下的M有效数位不足23位的用0补足23位，超过23位的只取到23位作为尾数
        
